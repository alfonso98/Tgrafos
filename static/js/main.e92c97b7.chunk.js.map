{"version":3,"sources":["componentes/grapher.js","componentes/opciones.js","componentes/opciones2.js","componentes/clasificacion.js","componentes/base.js","App.js","serviceWorker.js","index.js"],"names":["Graficador","_ref","graph","nodes","nodos","edges","lineas","options","height","layout","hierarchical","color","shadow","smooth","arrows","to","enabled","tipo","scaleFactor","type","middle","from","react_default","a","createElement","lib_default","useStyles","makeStyles","theme","card","background","textField","marginLeft","spacing","marginRight","form","display","flexDirection","margin","width","formControl","marginTop","minWidth","top","formControlLabel","LineaElemento","respuesta","classes","_useState","useState","_useState2","Object","slicedToArray","opc","setOpc","FormControl","className","InputLabel","Select","value","onChange","e","target","map","valor","MenuItem","id","key","label","LineaElement","Clasify","Portada","_this","this","check","setCheck","_useState3","_useState4","check2","setCheck2","_useState5","_useState6","numNodos","setNumNodos","_useState7","_useState8","numLineas","setNumLineas","_useState9","_useState10","digraph","setDiagraph","_useState11","_useState12","setNodes","_useState13","_useState14","lines","setLines","_useState15","_useState16","_useState17","_useState18","opc2","setOpc2","opcHandler","num","copia","data","opc2Handler","copia2","Grid","container","direction","alignItems","item","xs","Card","CardContent","Typography","variant","TextField","n","parseInt","v","i","push","toString","createNodos","l","j","aux","createLineas","FormControlLabel","control","Switch","checked","val","index","justify","opciones","bind","opciones2","Button","onClick","hidden","style","grapher","App","base","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e92c97b7.chunk.js","sourcesContent":["import React from \"react\";\r\nimport Graph from \"react-graph-vis\";\r\n\r\nfunction Graficador({nodos,lineas,tipo}) {\r\n\r\n  const graph = {\r\n    nodes: nodos,\r\n    edges: lineas\r\n  };\r\n\r\n\r\n\r\n\r\n  const options = {\r\n    height: \"800px\",\r\n    layout: {\r\n      hierarchical: false\r\n    },\r\n    edges: {\r\n      color: \"#000000\",\r\n      shadow: true,\r\n      smooth: true,\r\n      arrows: {\r\n        to:     {enabled: tipo, scaleFactor:1, type:'arrow'},\r\n        middle: {enabled: false, scaleFactor:1, type:'arrow'},\r\n        from:   {enabled: false, scaleFactor:1, type:'arrow'}\r\n      },\r\n  \r\n    },\r\n    \r\n  };\r\n  \r\n\r\n  return (\r\n    <Graph\r\n      graph={graph}\r\n      options={options}\r\n    />\r\n  );\r\n}\r\nexport default Graficador;\r\n","import React, { useState } from \"react\";\r\nimport \"typeface-roboto\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport InputLabel from \"@material-ui/core/InputLabel\";\r\nimport MenuItem from \"@material-ui/core/MenuItem\";\r\nimport FormControl from \"@material-ui/core/FormControl\";\r\nimport Select from \"@material-ui/core/Select\";\r\n\r\nconst useStyles = makeStyles(theme => ({\r\n    card: {\r\n      background: \"#ffffff\"\r\n    },\r\n    textField: {\r\n      marginLeft: theme.spacing(1),\r\n      marginRight: theme.spacing(1)\r\n    },\r\n    form: {\r\n      display: \"flex\",\r\n      flexDirection: \"column\",\r\n      margin: \"auto\",\r\n      width: \"fit-content\"\r\n    },\r\n    formControl: {\r\n      marginTop: 0,\r\n      minWidth: 120,\r\n      top: -9,\r\n    },\r\n    formControlLabel: {\r\n      marginTop: theme.spacing(1)\r\n    }\r\n  }));\r\n\r\nfunction LineaElemento({nodes, respuesta}) {\r\n    const classes = useStyles();\r\n    const [opc , setOpc] = useState(\"\");\r\n\r\n    const opchandler = (e) =>{\r\n        setOpc(e.target.value);\r\n        respuesta(e);\r\n    };\r\n\r\n    return (\r\n      <FormControl className={classes.formControl}>\r\n        <InputLabel>Nodo</InputLabel>\r\n        <Select value={opc} onChange={opchandler}>\r\n          {nodes.map(valor => {\r\n            return( <MenuItem value={valor.id} key={valor.key}> {valor.label}</MenuItem>);\r\n          })}\r\n        </Select>\r\n      </FormControl>\r\n    );\r\n  }\r\n\r\n  export default LineaElemento;","import React, { useState } from \"react\";\r\nimport \"typeface-roboto\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport InputLabel from \"@material-ui/core/InputLabel\";\r\nimport MenuItem from \"@material-ui/core/MenuItem\";\r\nimport FormControl from \"@material-ui/core/FormControl\";\r\nimport Select from \"@material-ui/core/Select\";\r\n\r\nconst useStyles = makeStyles(theme => ({\r\n    card: {\r\n      background: \"#ffffff\"\r\n    },\r\n    textField: {\r\n      marginLeft: theme.spacing(1),\r\n      marginRight: theme.spacing(1)\r\n    },\r\n    form: {\r\n      display: \"flex\",\r\n      flexDirection: \"column\",\r\n      margin: \"auto\",\r\n      width: \"fit-content\"\r\n    },\r\n    formControl: {\r\n      marginTop: 0,\r\n      minWidth: 120,\r\n      top: -9,\r\n    },\r\n    formControlLabel: {\r\n      marginTop: theme.spacing(1)\r\n    }\r\n  }));\r\n\r\nfunction LineaElement({nodes, respuesta}) {\r\n    const classes = useStyles();\r\n    const [opc , setOpc] = useState(\"\");\r\n\r\n    const opchandler = (e) =>{\r\n        setOpc(e.target.value);\r\n        respuesta(e);\r\n    };\r\n\r\n    return (\r\n      <FormControl className={classes.formControl}>\r\n        <InputLabel>Nodo</InputLabel>\r\n        <Select value={opc} onChange={opchandler}>\r\n          {nodes.map(valor => {\r\n            return( <MenuItem value={valor.id} key={valor.key}> {valor.label}</MenuItem>);\r\n          })}\r\n        </Select>\r\n      </FormControl>\r\n    );\r\n  }\r\n\r\n  export default LineaElement;","import React  from \"react\";\r\nimport * as math from 'mathjs'\r\nimport { Typography } from '@material-ui/core';\r\n\r\n\r\nfunction Clasify({numnodes, numlines, nodes, lines, type}) {\r\n\r\n    const graficas =() =>{\r\n        console.log(\"es gráfica\");\r\n        console.log(numnodes);\r\n        console.log(numlines);\r\n        \r\n        let A = new Array(numnodes); //Matriz de incidencia\r\n        let X = new Array(numnodes); //Matriz de adyacencia\r\n        let M = new Array(numnodes);\r\n        let bucles = []; //almacena las lineas que son bucles\r\n        let aislados = [] //almacena los vertices aislados\r\n        let colgantes = [] //almacena vertices colgantes\r\n        let grados = nodes;\r\n        let paralelas = lines;\r\n        let enserie = lines;\r\n        let arr = [];\r\n        let arr2 = [];\r\n        let arr3=[];\r\n\r\n\r\n        let gsimple=false, ggeneral=false, gconectada=false, gdesconectada=false, gregular=false;\r\n        let i,j,k;\r\n        let a=0, b=0,p, gsg, gcd, gr,ban, grado=0, cont=0;\r\n        \r\n        \r\n        for(i=0;i<numnodes;i++)\r\n        {\r\n            for(j=0;j<numlines;j++)\r\n            {\r\n                arr.push(0);\r\n            }\r\n            A[i]= arr;\r\n            arr = [];\r\n        }\r\n        for(i=0;i<numnodes;i++)\r\n        {\r\n            for(j=0;j<numnodes;j++)\r\n            {\r\n                arr2.push(0);\r\n                arr3.push(0);\r\n            }\r\n            X[i] = arr2;\r\n            M[i] = arr3;\r\n            arr2 =[];\r\n            arr3=[];\r\n        }\r\n        \r\n        for(j=0; j<numlines; j++){\r\n            a = parseInt(lines[j].from);\r\n            b = parseInt(lines[j].to);\r\n            A[a-1][j] = 1;\r\n            A[b-1][j] = 1;\r\n            X[a-1][b-1] = 1;\r\n            X[b-1][a-1] = 1;\r\n            // M[a-1][b-1] = \"+\";\r\n            // M[b-1][a-1] = \"+\";\r\n        }\r\n\r\n        console.log(A);\r\n        console.log(X);\r\n        console.log(M);\r\n\r\n        /** Ciclo para encontrar los bucles en la matriz de incidencia **/\r\n        for(i=0; i<numlines; i++){\r\n            for(j=0; j<numnodes; j++){\r\n                if(A[j][i]!==0){\r\n                    cont++;\r\n                }\r\n            }\r\n            if(cont === 1){\r\n                bucles.push(i+1);// se almacenan todas las lineas que sí son bucles\r\n                gsg = 1;\r\n            }\r\n            cont = 0;\r\n        }\r\n        \r\n        /** Ciclo para encontrar los vertices aislados en la matriz de incidencia **/\r\n        for(i=0; i< numnodes; i++){\r\n            for(j=0; j< numlines; j++){\r\n                if(A[i][j] !== 0){\r\n                    ban=1;\r\n                    grado++;\r\n                }\r\n            }\r\n            if(ban === 0){\r\n                aislados.push(i+1)\r\n                gcd =1;\r\n            }else{\r\n                if(grado ===1){\r\n                    grado=0;\r\n                    colgantes.push(i+1);\r\n                }else{\r\n                    grados[i+1] = grado;\r\n                    grado =0;\r\n                }\r\n            }\r\n            ban =0;\r\n        }\r\n        \r\n        /** Ciclo para encontrar las líneas paralelas **/\r\n        cont=0;\r\n            for(i=0;i<numlines;i++)\r\n            {\r\n                for(j=i+1;j<numlines;j++)\r\n                {\r\n                    for(k=0;k<numnodes;k++)\r\n                    {\r\n                        if (A[k][i]===A[k][j])\r\n                        {\r\n                            cont++;\r\n                        }\r\n                    }\r\n                    if(cont===numnodes)\r\n                    {\r\n                        paralelas[i+1] = j+1;\r\n                    }\r\n                    cont=0; /** Se reinicia el contador cuando se cambia de columna**/\r\n                }\r\n            }\r\n        \r\n        \r\n        /** Ciclo para encontrar las líneas en serie **/\r\n            cont=0;\r\n            grado=0;\r\n            for(i=0;i<numlines;i++)\r\n            {\r\n                for(j=i+1;j<numlines;j++)\r\n                {\r\n                    for(k=0;k<numnodes;k++)\r\n                    {\r\n                        if (A[k][i]===A[k][j] && A[k][i]===1)\r\n                        {\r\n                            cont++;\r\n                            a=k;\r\n                        }\r\n                    }\r\n                    if(cont===1)\r\n                    {\r\n                        for(p=0;p<numlines;p++)\r\n                        {\r\n                            if(A[a][p]!==0)\r\n                            {\r\n                                grado++;\r\n                            }\r\n                        }\r\n                        if(grado===2)\r\n                        {\r\n                            enserie[i+1] = j+1;\r\n                            //printf(\"\\n La linea %d y la linea %d estan en serie \\n\",i+1,j+1);\r\n                        }\r\n                    }\r\n                    cont=0; /** Se reinicia el contador cuando se cambia de columna**/\r\n                    grado=0;\r\n                }\r\n            }\r\n        \r\n        /** Clasificación de gráficas **/\r\n        \r\n        if(gsg===0)\r\n        {\r\n            //printf(\"\\n Es una grafica simple\\n\");\r\n            gsimple=true;\r\n        }\r\n        else\r\n        {\r\n            //printf(\"\\n Es una grafica general\\n\");\r\n            ggeneral =true;\r\n        }\r\n        \r\n        if(gcd===0)\r\n        {\r\n            //printf(\"\\n La grafica esta conectada\\n\");\r\n            gconectada =true;\r\n        }\r\n        else\r\n        {\r\n            //printf(\"\\n La grafica esta desconectada\\n\");\r\n            gdesconectada=true;\r\n        }\r\n        grado=0;\r\n        for(i=0;i<numnodes;i++)\r\n        {\r\n            for(j=0;j<numlines;j++)\r\n            {\r\n                grado+=A[i][j];\r\n            }\r\n            if(i===0)\r\n            {\r\n                a=grado;\r\n                grado=0;\r\n            }\r\n            else\r\n            {\r\n                if(grado!==a)\r\n                {\r\n                    gr=1;\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    a=grado;\r\n                    grado=0;\r\n                }\r\n            }\r\n        \r\n        }\r\n        if(gr===0)\r\n        {\r\n            //printf(\"\\n La grafica es regular\");\r\n            gregular=true;\r\n        }\r\n        \r\n        console.log(\"G. Simple: \",gsimple);\r\n        console.log(\"G. Conectada: \",gconectada);\r\n        console.log(\"G. Desconectada: \",gdesconectada);\r\n        console.log(\"G. General: \",ggeneral);\r\n        console.log(\"G. Regular: \",gregular);\r\n        \r\n        return(\r\n            <div>\r\n                <Typography>Clasificación de la gráfica:</Typography>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const digraficas = () => {\r\n        console.log(\"es digráfica\");\r\n        const A = math.zeros([numnodes,numlines]); //Matriz de incidencia\r\n        const X = math.zeros([numnodes,numnodes]); //Matriz de adyacencia\r\n        //const M = math.zeros([numnodes,numnodes]);\r\n        const bucles = []; //almacena las lineas que son bucles\r\n        const aislados = [] //almacena los vertices aislados\r\n        const grexternos = nodes;\r\n        const grinternos = nodes;\r\n        const paralelas = lines;\r\n     \r\n\r\n        let gsimple=false, ggeneral=false, gconectada=false, gdesconectada=false, gbalancead = true,  garbol= true;\r\n        let i,j,k;\r\n        let a, b, gsg, gcd, gb,ban, cont=0,grado_ext=0,grado_int=0;\r\n\r\n        for(j=0;j<numlines;j++){\r\n            a = parseInt(lines[j].from);\r\n            b = parseInt(lines[j].to);\r\n            A[a-1][j]=1;       /** Se llena la matriz de incidencia en la lectura de datos **/\r\n            A[b-1][j]=-1;\r\n            X[a-1][b-1]=1;     /** Se llena la matriz de adyacencia en la lectura de datos **/\r\n            if(a===b){\r\n                A[a-1][j]=\"+\"; /** Bucles en la matriz de incidencia **/\r\n            }\r\n        }\r\n\r\n         /** Ciclo para encontrar los bucles en la matriz de incidencia **/\r\n\r\n     for(i=0;i<numlines;i++)\r\n     {\r\n         for(j=0;j<numnodes;j++)\r\n         {\r\n            if(A[j][i]!==0)\r\n            {\r\n                cont++;  /** Contador  de bucles **/\r\n            }\r\n         }\r\n         if(cont===1)\r\n         {\r\n             //printf(\"\\n La linea %d es un bucle\\n\",i+1);\r\n             bucles.push(i+1);\r\n             gsg=1;\r\n         }\r\n         cont=0;  /** Reinicio del contador para buscar un bucle en la siguiente columna **/\r\n     }\r\n \r\n \r\n     /** Ciclo para encontrar los vertices aislados en la matriz de incidencia **/\r\n \r\n     for(i=0;i<numnodes;i++)\r\n     {\r\n         for(j=0;j<numlines;j++)\r\n         {\r\n            if (A[i][j]!==0)\r\n            {\r\n                ban=1; /** Bandera de vertices aislados **/\r\n                if(A[i][j]===1)\r\n                {\r\n                    grado_ext++;\r\n                }\r\n                else\r\n                {\r\n                    grado_int++;\r\n                }\r\n            }\r\n         }\r\n         if(ban===0)\r\n         {\r\n             //printf(\"\\n El vertice %d es aislado\\n\",i+1);\r\n             aislados.push(i+1);\r\n             gcd=1;  /** Bandera para determinar si está conectada **/\r\n         }\r\n         else\r\n         {\r\n             //printf(\"\\n El vertice %d tiene grado externo %d y grado interno %d\\n\",i+1,grado_ext,grado_int);\r\n             grexternos[i+1]=grado_ext;\r\n             grinternos[i+1]=grado_int;\r\n             grado_ext=0;\r\n             grado_int=0;\r\n         }\r\n         ban=0;   /** Se desactiva la bandera para volver a buscar en caso de haber encontrado una coincidencia**/\r\n \r\n     }\r\n\r\n     /** Ciclo para encontrar las líneas paralelas **/\r\n\r\n    cont=0;\r\n    for(i=0;i<numlines;i++)\r\n    {\r\n        for(j=i+1;j<numlines;j++)\r\n        {\r\n            for(k=0;k<numnodes;k++)\r\n            {\r\n                if (A[k][i]===A[k][j])\r\n                {\r\n                    cont++;\r\n                }\r\n            }\r\n            if(cont===numnodes)\r\n            {\r\n                //printf(\"\\n La linea %d es paralela a la linea %d\\n\",i+1,j+1);\r\n                paralelas[i+1] = j+1;\r\n            }\r\n            cont=0; /** Se reinicia el contador cuando se cambia de columna**/\r\n        }\r\n    }\r\n \r\n     /** Clasificación de gráficas **/\r\n\r\n     if(gsg===0)\r\n     {\r\n         //printf(\"\\n Es una grafica simple\\n\");\r\n         gsimple=true;\r\n     }\r\n     else\r\n     {\r\n         //printf(\"\\n Es una grafica general\\n\");\r\n         ggeneral=true;\r\n     }\r\n \r\n     if(gcd===0)\r\n     {\r\n         //printf(\"\\n La grafica esta conectada\\n\");\r\n         gconectada=true;\r\n     }\r\n     else\r\n     {\r\n         //printf(\"\\n La grafica esta desconectada\\n\");\r\n         gdesconectada=true;\r\n     }\r\n \r\n     grado_ext=0;\r\n     grado_int=0;\r\n     for(i=0;i<numnodes;i++)\r\n     {\r\n         for(j=0;j<numlines;j++)\r\n         {\r\n             if(A[i][j]===1)\r\n             {\r\n                 grado_ext++;\r\n             }\r\n             if(A[i][j]===-1)\r\n             {\r\n                 grado_int++;\r\n             }\r\n         }\r\n         if(grado_ext!==grado_int)\r\n         {\r\n             gb=1;\r\n             break;\r\n         }\r\n         else\r\n         {\r\n             if(i===0)\r\n             {\r\n                 a=grado_ext;\r\n                 b=grado_int;\r\n                 grado_ext=0;\r\n                 grado_int=0;\r\n             }\r\n             else\r\n             {\r\n                 if(a!==grado_ext || b!==grado_int)\r\n                 {\r\n                     gb=1;\r\n                     break;\r\n                 }\r\n                 else\r\n                 {\r\n                     a=grado_ext;\r\n                     b=grado_int;\r\n                     grado_ext=0;\r\n                     grado_int=0;\r\n                 }\r\n             }\r\n         }\r\n \r\n     }\r\n     if(gb===0)\r\n     {\r\n         //printf(\"\\n La grafica es balanceada\");\r\n         gbalancead = true;\r\n     }\r\n \r\n     /** Arboles **/\r\n \r\n     if(numlines===numnodes-1)\r\n     {\r\n         if(gsg===0)\r\n         {\r\n            // printf(\"\\n La grafica es un arbol\\n\");\r\n             garbol= true;\r\n         }\r\n     }\r\n    \r\n     console.log(gsimple);\r\n     console.log(ggeneral);\r\n     console.log(gconectada);\r\n     console.log(gdesconectada);\r\n     console.log(gbalancead);\r\n     console.log(garbol);\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    if(type === true){\r\n        digraficas();\r\n    }else{\r\n        graficas();\r\n    };\r\n\r\n}\r\nexport default Clasify;","import React, { useState } from \"react\";\r\nimport \"typeface-roboto\";\r\nimport Grid from \"@material-ui/core/Grid\";\r\nimport Card from \"@material-ui/core/Card\";\r\nimport CardContent from \"@material-ui/core/CardContent\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\nimport { Button, TextField, FormControlLabel } from \"@material-ui/core\";\r\nimport Graficador from \"./grapher\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport Switch from \"@material-ui/core/Switch\";\r\nimport LineaElemento from './opciones';\r\nimport LineaElement from './opciones2';\r\nimport Clasify from './clasificacion';\r\n\r\n\r\n\r\nconst useStyles = makeStyles(theme => ({\r\n  card: {\r\n    background: \"#ffffff\"\r\n  },\r\n  textField: {\r\n    marginLeft: theme.spacing(1),\r\n    marginRight: theme.spacing(1)\r\n  },\r\n  form: {\r\n    display: \"flex\",\r\n    flexDirection: \"column\",\r\n    margin: \"auto\",\r\n    width: \"fit-content\"\r\n  },\r\n  formControl: {\r\n    marginTop: theme.spacing(2),\r\n    minWidth: 120\r\n  },\r\n  formControlLabel: {\r\n    marginTop: theme.spacing(1)\r\n  }\r\n}));\r\n\r\nfunction Portada() {\r\n  const classes = useStyles();\r\n  const [check, setCheck] = useState(true);\r\n  const [check2, setCheck2] = useState(true);\r\n  const [numNodos, setNumNodos] = useState(\"\");\r\n  const [numLineas, setNumLineas] = useState(\"\");\r\n  const [digraph, setDiagraph] = useState(false); //si es true--> digráfica | si es false --> gráfica\r\n  const [nodes, setNodes] = useState([]);\r\n  const [lines, setLines] = useState([]);\r\n  const [opc, setOpc] = useState([]);\r\n  const [opc2 , setOpc2] = useState([]);\r\n\r\n  const createNodos = v => {\r\n    let i;\r\n    let data = [];\r\n    for (i = 1; i <= v; i++) {\r\n      data.push({\r\n        id: i.toString(),\r\n        label: \"V\" + i.toString()\r\n      });\r\n    }\r\n    setNodes(data);\r\n  };\r\n\r\n  const createLineas = l => {\r\n    let j;\r\n    let data = [];\r\n    let aux = [];\r\n    for (j = 1; j <= l; j++) {\r\n      data.push({\r\n        from: \"0\",\r\n        to: \"0\",\r\n        label: j.toString()\r\n      });\r\n      aux.push(\"\");\r\n    }\r\n    setLines(data);\r\n    setOpc(aux);\r\n    setOpc2(aux);\r\n  };\r\n\r\n  const muestraHandler = () => {\r\n    setCheck(!check); //HACE VISIBLE EL COMPONENTE CON LA GRÁFICA\r\n    setCheck2(!check2);\r\n  };\r\n\r\n  const numNodosHandler = e => {\r\n    let n = parseInt(e.target.value);\r\n\r\n    if (n === \"\") {\r\n      setNumNodos(\"\");\r\n    } else {\r\n      if (n > 0) {\r\n        setNumNodos(e.target.value);\r\n      } else {\r\n        setNumNodos(e.target.value);\r\n      }\r\n    }\r\n\r\n    createNodos(n);\r\n  };\r\n\r\n  const numLineasHandler = e => {\r\n    let n = parseInt(e.target.value);\r\n\r\n    if (n === \"\") {\r\n      setNumLineas(\"\");\r\n    } else {\r\n      if (n > 0) {\r\n        setNumLineas(e.target.value);\r\n      } else {\r\n        setNumLineas(\"\");\r\n      }\r\n    }\r\n    createLineas(parseInt(e.target.value));\r\n  };\r\n\r\n  const tipoHandler = () => {\r\n    setDiagraph(!digraph);\r\n  };\r\n\r\n  const opcHandler = (num, e) => {\r\n    const copia = opc;\r\n    copia[num] = e.target.value;\r\n    setOpc(copia);\r\n    const data = lines;\r\n    data[num].from = e.target.value;\r\n    setLines(data);\r\n  };\r\n\r\n  const opc2Handler = (num, e) => {\r\n    const copia2 = opc2;\r\n    copia2[num] = e.target.value;\r\n    setOpc2(copia2);\r\n    const data = lines;\r\n    data[num].to = e.target.value;\r\n    setLines(data);\r\n\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <Grid\r\n        container\r\n        direction=\"column\"\r\n        alignItems=\"center\"\r\n        spacing={7}\r\n      >\r\n        <Grid item xs={12} />\r\n        <Card>\r\n          <CardContent>\r\n            <Typography variant=\"h3\"> Teoría de Gráficas</Typography>\r\n\r\n            <TextField\r\n              id=\"outlined-name\"\r\n              label=\"Nodos\"\r\n              value={numNodos}\r\n              onChange={numNodosHandler}\r\n              margin=\"normal\"\r\n              variant=\"outlined\"\r\n            />\r\n\r\n            <TextField\r\n              id=\"outlined-name\"\r\n              label=\"Lineas\"\r\n              className={classes.textField}\r\n              value={numLineas}\r\n              onChange={numLineasHandler}\r\n              margin=\"normal\"\r\n              variant=\"outlined\"\r\n            />\r\n\r\n            <FormControlLabel\r\n              control={\r\n                <Switch\r\n                  checked={digraph}\r\n                  onChange={tipoHandler}\r\n                  value=\"checkedB\"\r\n                  color=\"primary\"\r\n                  label={\"gráfica\"}\r\n                />\r\n              }\r\n              label={digraph ? \"Digráfica\" : \"Gráfica\"}\r\n            />\r\n\r\n            {lines.map((val, index) => {\r\n              return (\r\n                <Card key={val.key}>\r\n                  <Grid\r\n                    container\r\n                    direction=\"row\"\r\n                    justify=\"flex-start\"\r\n                    alignItems=\"center\"\r\n                  >\r\n                    <Typography>Linea {val.label} : Conecta </Typography>\r\n                    <br />\r\n                    <br />\r\n                    <LineaElemento nodes={nodes} respuesta={opcHandler.bind(this,index)}/>\r\n                    <br />\r\n                    <br />\r\n                    <Typography> con el nodo: </Typography>\r\n                    <LineaElement nodes={nodes} respuesta={opc2Handler.bind(this, index)} />\r\n                  </Grid>\r\n                </Card>\r\n              );\r\n            })}\r\n            <br />\r\n            <Button onClick={muestraHandler}>Graficar</Button>\r\n          </CardContent>\r\n        </Card>\r\n      </Grid>\r\n      <br />\r\n      <br />\r\n      <br />\r\n      <br />\r\n      {/* <Grid item xs={12}>\r\n            <Card hidden={check2 }>\r\n                <CardContent>\r\n                {\r\n                !check2 ? <Clasify numnodes={parseInt(numNodos)} \r\n                numlines={parseInt(numLineas)} \r\n                nodes={nodes} \r\n                lines={lines} \r\n                type={digraph} /> : false\r\n                }\r\n                </CardContent>\r\n            </Card>\r\n      </Grid> */}\r\n      <br />\r\n      <br />\r\n      <br />\r\n      <br />\r\n      <Grid item xs={12} >\r\n        <Card hidden={check2} style={{width: \"80%\", height: \"1000px\"}}>\r\n          <CardContent>\r\n            {!check2 ?    <Graficador\r\n                nodos={nodes}\r\n                lineas={lines}\r\n                tipo={digraph}\r\n                style={{ height: \"1000px\" }}\r\n              /> : false}\r\n           \r\n          </CardContent>\r\n        </Card>\r\n      </Grid>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Portada;\r\n","import React from 'react';\nimport './App.css';\nimport Portada from './componentes/base';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Portada/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}